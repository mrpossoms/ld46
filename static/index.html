<html>
<head>
<link href="css/style.css" rel="stylesheet">
<script src="/socket.io/socket.io.js"></script>
<script type="text/javascript" src="js/g.js" charset="UTF-8"></script>
<script type="text/javascript" src="js/g.web.js" charset="UTF-8"></script>
<script type="text/javascript">

const k = {
    mouse: {
        sensitivity: 0.005
    },
    player: {
        speed: 10,
        sprint: 3,
    }
};

var game = {
    state: {
        player: {
            cam: new g.web.gfx.camera(),
            pos: [32, 0, 32],
            fov: Math.PI / 2,
            interp_pos: [32, 0, 32],
            interp_fov: Math.PI / 2,
            vel: [0, 0, 0],
            yaw: 0,
            pitch: 0,
            bobble: 0,
            heading: function() { return [].quat_rotation([0, 1, 0], this.yaw).quat_rotate_vector([0, 0, 1]); }
        },
        bb_boi: {
            hp: 1,
            pizza: 1,
            bed_pan: 0,
            mtn_dew: 1,
            rates: {
                pizza_s: 0.01,
                bed_pan_s: 0.75,
                mtn_dew_s: 0.04
            },
            get_daipies: function() { return 1; }
        }
    }
}

function on_load()
{

g.web.canvas(document.getElementsByTagName('canvas')[0]);

g.initialize(function ()
{
    g.is_running = false;

    const asset_list = [
    'shaders/basic_colored.vert',
    'shaders/basic_colored.frag',
    'meshes/plane.json',
    'voxels/apt.json'
    ];

    game.state.player.cam.perspective();
    game.state.player.cam.position(game.state.player.pos);

    g.web.assets.load(asset_list,
    function() {
        g.web.gfx.shader.create('basic_colored',
            g.web.assets['shaders/basic_colored.vert'],
            g.web.assets['shaders/basic_colored.frag']
        );

        // g.web.assets['mesh/plane'] = g.web.gfx.mesh.create(g.web.assets["meshes/plane.json"]);
        g.web.assets['mesh/teapot'] = g.web.gfx.mesh.create(g.web.assets['meshes/exported-cube.json']);

        g.is_running = true;
        gl.getExtension('OES_element_index_uint');
    });

	return true;
});

g.web.pointer.on_press(function ()
{
    g.web._canvas.requestPointerLock();
});

g.web.pointer.on_move(function (event)
{
    game.state.player.yaw += event.movementX * k.mouse.sensitivity;
    const dp = -event.movementY * k.mouse.sensitivity;

    if (game.state.player.pitch + dp > -Math.PI / 4 &&
        game.state.player.pitch + dp <  Math.PI / 4)
    {
        game.state.player.pitch += dp;
    }

    var q = [].quat_rotation([0, 1, 0], game.state.player.yaw);
    q = q.quat_mul([].quat_rotation([1, 0, 0], game.state.player.pitch));
    game.state.player.cam.orientation(q);
});


g.web.on_message(function (msg)
{

});

function bb_boi_tick(boi, dt)
{
    const mul = boi.get_daipies();
    const pizza_delta = boi.rates.pizza_s * mul * dt;
    boi.pizza -= pizza_delta;
    boi.mtn_dew -= boi.rates.mtn_dew_s * mul * dt;
    boi.bed_pan += boi.rates.bed_pan_s * pizza_delta * dt;
}

g.update(function (dt)
{
    const forward = game.state.player.heading();
    const left = game.state.player.cam.left();
    var pos = game.state.player.pos;
    var vel = [0, 0, 0];

    var moving = false;
    var speed = k.player.speed;
    if (g.web.key.is_pressed('shift'))
    {
        speed *= k.player.sprint;
        game.state.player.fov = Math.PI / 2 * 1.2;
    }
    else
    {
        game.state.player.fov = Math.PI / 2 * 0.8;
    }

	if (g.web.key.is_pressed('w')) { moving = true; vel = vel.add(forward.mul(-dt * speed)); }
    if (g.web.key.is_pressed('s')) { moving = true; vel = vel.add(forward.mul(dt * speed)); }
    if (g.web.key.is_pressed('a')) { moving = true; vel = vel.add(left.mul(dt * speed)); }
    if (g.web.key.is_pressed('d')) { moving = true; vel = vel.add(left.mul(-dt * speed)); }

    if (moving)
    {
        game.state.player.bobble += dt * 10;
    }
    else
    {
        vel = game.state.player.vel.mul(0.9);
    }

    plane_pos = [ Math.cos(t), Math.sin(t), 0 ].mul(0);

    game.state.player.vel = vel;
    var tmp_pos = pos.add(vel);
    const space = g.web.assets['voxel/apt'].cells;

    var x = Math.floor(tmp_pos[0]), y = Math.floor(tmp_pos[1] + 1), z = Math.floor(tmp_pos[2]);
    var intersecting = false;

    y = Math.floor(tmp_pos[1]);

    for (var yi = 6; yi < 14; yi++)
    for (var xi = -1; xi <= 1; xi++)
    for (var zi = -1; zi <= 1; zi++)
    {
        if (space[x + xi][y + yi][z + zi])
        {
            intersecting = true;
        }
    }

    for (var yi = 14; --yi;)
    {
        if (space[x][y + yi][z])
        {
            if (yi <= 5)
            {
                tmp_pos[1] += yi;
                break;
            }
        }
    }

    if (y - 1 >= 0 && !space[x][y - 1][z]) { tmp_pos[1] -= 1; }

    if (!intersecting)
    {
        game.state.player.pos = tmp_pos;
    }

    game.state.player.interp_pos = game.state.player.interp_pos.lerp(tmp_pos, 0.25);
    game.state.player.interp_fov = game.state.player.interp_fov * 0.95 + game.state.player.fov * 0.05;

    var sway = [0, Math.sin(game.state.player.bobble), 0].add(left.mul(Math.cos(game.state.player.bobble * 0.5)));

    game.state.player.cam.perspective(game.state.player.interp_fov);
    game.state.player.cam.position(game.state.player.interp_pos.add(sway.mul(0.5).add([0, 14, 0])));
    // cam.view(cam.position, ([0, 0, 1]), ([0, 1, 0]));
});

var t = 0;

g.web.draw(function (dt)
{
    t += dt;
    if (g.is_running == false) { return; }

    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    const mesh = g.web.assets['voxel/apt'];

    // cam.perspective();

    // plane_q = plane_q.quat_mul([].quat_rotation([0, 0, 1], dt));

    // cam._view = cam.q.quat_to_matrix();

    mesh.using_shader('basic_colored')
        .with_attribute({name:'a_position', buffer: 'positions', components: 3})
        .with_attribute({name:'a_normal', buffer: 'normals', components: 3})
        .with_attribute({name:'a_color', buffer: 'colors', components: 3})
        .with_camera(game.state.player.cam)
        .set_uniform('u_model').mat4([].I(4))
        // .set_uniform('u_model').mat4(cam.q.quat_to_matrix())
        .set_uniform('u_texture').texture(g.web.assets['tex/stars'])
        .draw_tris();
});

g.start();
}

</script>
</head>

<body style="margin:0" onload="on_load()">
<canvas style="padding:0;margin:0;width:100%;height:100%"></canvas>
</body>
</html>
